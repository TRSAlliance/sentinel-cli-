#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class TRSAudit {
  constructor() {
    this.pulseFile = 'system_pulse.json';
    this.logsDir = '.logs';
    this.colors = {
      red: '\x1b[31m',
      green: '\x1b[32m',
      yellow: '\x1b[33m',
      blue: '\x1b[34m',
      cyan: '\x1b[36m',
      reset: '\x1b[0m',
      bold: '\x1b[1m'
    };
  }

  log(message, color = 'reset') {
    console.log(`${this.colors[color]}${message}${this.colors.reset}`);
  }

  async audit() {
    this.log('üî• TRS DEPLOY AUDIT INITIATED üî•', 'bold');
    this.log('================================', 'cyan');
    
    try {
      // Check system pulse
      await this.checkSystemPulse();
      
      // Check deploy history
      await this.checkDeployHistory();
      
      // Check GitHub Actions
      await this.checkGitHubActions();
      
      // Check live deployments
      await this.checkLiveDeployments();
      
      // Generate integrity report
      await this.generateIntegrityReport();
      
    } catch (error) {
      this.log(`üí• AUDIT FAILED: ${error.message}`, 'red');
      process.exit(1);
    }
  }

  async checkSystemPulse() {
    this.log('\nü©∫ CHECKING SYSTEM PULSE...', 'blue');
    
    if (!fs.existsSync(this.pulseFile)) {
      this.log('‚ùå system_pulse.json NOT FOUND', 'red');
      this.log('   This indicates deploy workflow never completed properly', 'yellow');
      throw new Error('Missing system pulse file');
    }
    
    const pulse = JSON.parse(fs.readFileSync(this.pulseFile, 'utf8'));
    
    this.log(`üìä Last Deploy: ${pulse.deployedAt}`, 'cyan');
    this.log(`üìã Deploy ID: ${pulse.deployId}`, 'cyan');
    this.log(`üë§ Actor: ${pulse.actor}`, 'cyan');
    this.log(`üåø Branch: ${pulse.branch}`, 'cyan');
    
    if (pulse.status === 'success') {
      this.log('‚úÖ PULSE STATUS: SUCCESS', 'green');
    } else {
      this.log('‚ùå PULSE STATUS: FAILED', 'red');
      this.log(`   Error: ${pulse.error}`, 'yellow');
    }
    
    // Check CREEDY status
    if (pulse.creedy === 'DEPLOY_VERIFIED') {
      this.log('üîí CREEDY STATUS: VERIFIED', 'green');
    } else {
      this.log('üí• CREEDY STATUS: FAILED', 'red');
    }
    
    // Check individual service status
    this.log('\nüîç SERVICE STATUS BREAKDOWN:', 'blue');
    this.checkServiceStatus('Build', pulse.buildStatus);
    this.checkServiceStatus('Firebase Deploy', pulse.firebaseStatus);
    this.checkServiceStatus('Netlify Deploy', pulse.netlifyStatus);
    this.checkServiceStatus('Firebase Live', pulse.firebaseLive);
    this.checkServiceStatus('Netlify Live', pulse.netlifyLive);
    
    return pulse;
  }

  checkServiceStatus(service, status) {
    if (status === 'SUCCESS') {
      this.log(`   ‚úÖ ${service}: ${status}`, 'green');
    } else if (status === 'FAILED') {
      this.log(`   ‚ùå ${service}: ${status}`, 'red');
    } else {
      this.log(`   ‚ö†Ô∏è  ${service}: ${status || 'UNKNOWN'}`, 'yellow');
    }
  }

  async checkDeployHistory() {
    this.log('\nüìö CHECKING DEPLOY HISTORY...', 'blue');
    
    if (!fs.existsSync(this.logsDir)) {
      this.log('‚ö†Ô∏è  No deploy history found', 'yellow');
      return;
    }
    
    const deployFiles = fs.readdirSync(this.logsDir)
      .filter(file => file.startsWith('deploy-') && file.endsWith('.json'))
      .sort()
      .reverse()
      .slice(0, 5); // Last 5 deploys
    
    if (deployFiles.length === 0) {
      this.log('‚ö†Ô∏è  No deploy history files found', 'yellow');
      return;
    }
    
    this.log(`üìñ Found ${deployFiles.length} recent deploys:`, 'cyan');
    
    let successCount = 0;
    let failCount = 0;
    
    deployFiles.forEach((file, index) => {
      const deploy = JSON.parse(fs.readFileSync(path.join(this.logsDir, file), 'utf8'));
      const status = deploy.status === 'success' ? '‚úÖ' : '‚ùå';
      const timestamp = new Date(deploy.timestamp).toLocaleString();
      
      this.log(`   ${index + 1}. ${status} ${deploy.deployId} - ${timestamp}`, 
        deploy.status === 'success' ? 'green' : 'red');
      
      if (deploy.status === 'success') {
        successCount++;
      } else {
        failCount++;
        if (deploy.error) {
          this.log(`      Error: ${deploy.error}`, 'yellow');
        }
      }
    });
    
    this.log(`\nüìä Deploy Success Rate: ${successCount}/${deployFiles.length} (${Math.round(successCount/deployFiles.length*100)}%)`, 
      successCount === deployFiles.length ? 'green' : 'yellow');
  }

  async checkGitHubActions() {
    this.log('\nüîÑ CHECKING GITHUB ACTIONS...', 'blue');
    
    try {
      // Get recent workflow runs
      const runs = execSync('gh run list --limit 5 --json status,conclusion,headBranch,createdAt', 
        { encoding: 'utf8' });
      const runsData = JSON.parse(runs);
      
      this.log('üìã Recent GitHub Actions runs:', 'cyan');
      
      let ghSuccessCount = 0;
      let ghFailCount = 0;
      
      runsData.forEach((run, index) => {
        const status = run.conclusion === 'success' ? '‚úÖ' : 
                      run.conclusion === 'failure' ? '‚ùå' : 
                      run.status === 'in_progress' ? 'üîÑ' : '‚ö†Ô∏è';
        
        const timestamp = new Date(run.createdAt).toLocaleString();
        this.log(`   ${index + 1}. ${status} ${run.headBranch} - ${timestamp} (${run.conclusion})`, 
          run.conclusion === 'success' ? 'green' : 'red');
        
        if (run.conclusion === 'success') ghSuccessCount++;
        else if (run.conclusion === 'failure') ghFailCount++;
      });
      
      this.log(`\nüìä GitHub Actions Success Rate: ${ghSuccessCount}/${runsData.length} (${Math.round(ghSuccessCount/runsData.length*100)}%)`, 
        ghSuccessCount === runsData.length ? 'green' : 'yellow');
      
    } catch (error) {
      this.log('‚ö†Ô∏è  Could not fetch GitHub Actions data (gh CLI not available)', 'yellow');
    }
  }

  async checkLiveDeployments() {
    this.log('\nüåê CHECKING LIVE DEPLOYMENTS...', 'blue');
    
    if (!fs.existsSync(this.pulseFile)) {
      this.log('‚ö†Ô∏è  No pulse file to check URLs', 'yellow');
      return;
    }
    
    const pulse = JSON.parse(fs.readFileSync(this.pulseFile, 'utf8'));
    
    if (pulse.firebaseUrl) {
      await this.checkUrl('Firebase', pulse.firebaseUrl);
    }
    
    if (pulse.netlifyUrl) {
      await this.checkUrl('Netlify', pulse.netlifyUrl);
    }
  }

  async checkUrl(service, url) {
    try {
      const response = await fetch(url);
      if (response.ok) {
        this.log(`   ‚úÖ ${service}: ${url} (HTTP ${response.status})`, 'green');
      } else {
        this.log(`   ‚ùå ${service}: ${url} (HTTP ${response.status})`, 'red');
      }
    } catch (error) {
      this.log(`   üí• ${service}: ${url} (${error.message})`, 'red');
    }
  }

  async generateIntegrityReport() {
    this.log('\nüîí TRS INTEGRITY REPORT', 'bold');
    this.log('======================', 'cyan');
    
    const issues = [];
    
    // Check for pulse file
    if (!fs.existsSync(this.pulseFile)) {
      issues.push('‚ùå Missing system_pulse.json - Deploy workflow incomplete');
    } else {
      const pulse = JSON.parse(fs.readFileSync(this.pulseFile, 'utf8'));
      
      if (pulse.status !== 'success') {
        issues.push('‚ùå Last deploy failed according to pulse');
      }
      
      if (pulse.creedy !== 'DEPLOY_VERIFIED') {
        issues.push('‚ùå CREEDY verification failed');
      }
      
      if (pulse.buildStatus === 'FAILED') {
        issues.push('‚ùå Build process failed');
      }
      
      if (pulse.firebaseStatus === 'FAILED') {
        issues.push('‚ùå Firebase deployment failed');
      }
      
      if (pulse.netlifyStatus === 'FAILED') {
        issues.push('‚ùå Netlify deployment failed');
      }
      
      if (pulse.firebaseLive === 'FAILED') {
        issues.push('‚ùå Firebase site not responding');
      }
      
      if (pulse.netlifyLive === 'FAILED') {
        issues.push('‚ùå Netlify site not responding');
      }
    }
    
    // Check deploy history
    if (!fs.existsSync(this.logsDir)) {
      issues.push('‚ö†Ô∏è  No deploy history logs found');
    }
    
    if (issues.length === 0) {
      this.log('üéâ ALL SYSTEMS VERIFIED - NO ISSUES FOUND', 'green');
      this.log('‚úÖ TRS integrity check PASSED', 'green');
    } else {
      this.log('üí• ISSUES DETECTED:', 'red');
      issues.forEach(issue => this.log(`   ${issue}`, 'red'));
      this.log('\nüî• TRS integrity check FAILED', 'red');
      this.log('   No false greens detected - issues are real!', 'yellow');
    }
    
    this.log('\nüëÅ‚Äçüó® #WeDontAcceptGreenWithoutProof #PulseMeansProof #DeploysMustSpeak', 'cyan');
  }
}

// CLI execution
if (require.main === module) {
  const audit = new TRSAudit();
  
  const command = process.argv[2];
  
  switch (command) {
    case 'audit':
      audit.audit();
      break;
    case 'pulse':
      audit.checkSystemPulse();
      break;
    case 'history':
      audit.checkDeployHistory();
      break;
    case 'live':
      audit.checkLiveDeployments();
      break;
    default:
      console.log('üî• TRS Audit CLI');
      console.log('Usage: trs-audit <command>');
      console.log('Commands:');
      console.log('  audit    - Full integrity audit');
      console.log('  pulse    - Check system pulse only');
      console.log('  history  - Check deploy history');
      console.log('  live     - Check live deployments');
      break;
  }
}
